#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use File::Temp;
use Term::ANSIColor qw(:constants);

my ($LASTCHANGEDBY) = q$LastChangedBy: konganti $ =~ m/.+?\:(.+)/;
my ($LASTCHANGEDDATE) = q$LastChangedDate: 2013-10-09 12:46:11 -0500 (Wed, 09 Oct 2013) $ =~ m/.+?\:(.+)/;
my ($VERSION) = q$LastChangedRevision: 64 $ =~ m/.+?(\d+)/;
my $AUTHORFULLNAME = 'Kranti Konganti';

my ($help, $quiet, $setup, $get_uq_sc_opts,
    $fetch_sc_opts, $categorize_sc_opts,
    $cuffcmp_opts, $deps, $run, $out);


my $is_valid_option = GetOptions('help|?'            => \$help,
                                 'quiet'             => \$quiet,
				 'setup'             => \$setup,
				 'run'               => \$run, 
				 'cuffcompare=s'     => \$cuffcmp_opts,
				 'out=s'             => \$out,
				 'cat-ncRNAs=s'      => \$categorize_sc_opts,
				 'fetch-seq=s'       => \$fetch_sc_opts,
				 'get-feat=s'        => \$get_uq_sc_opts);

my $CAT_SC = 'categorize_ncRNAs.pl';
my $FETCH_SC = 'fetch_seq_from_ucsc.pl';
my $GET_UQ_SC = 'get_unique_features.pl';
my $USER_HOME = $ENV{'HOME'};

setup_ncRNAScan(`pwd`) if (defined $setup);
run_ncRNAScan(`pwd`) if (defined $run || defined $help);

sub run_ncRNAScan {
    chomp(my $ran_fromHere = shift);
    my $outdir;

    $ran_fromHere .= '/' if ($ran_fromHere !~ m/\/$/);
    
    open(my $pl_dep_paths_fh, '<', $USER_HOME . '/.ncRNAScan.PERLLIBS') ||
	die "\nCannot open $USER_HOME/.ncRNAScan.PERLLIBS. May be setup was unsuccessful (?): $!\!\n" .
	"Run \"$0 -setup\" to try to setup ncRNAScan pipeline.\n\n";
    my $pl_dep_paths = do { local $/; <$pl_dep_paths_fh> };
    my $pl_inc_string = source_env($pl_dep_paths);

    # We will quit, if the setup was unsuccessful.
    require IO::Routine;
    my $io = IO::Routine->new($help, $quiet);

    if (!defined $outdir) {
	$outdir = $io->validate_create_path($out, 'do not create',
					    'Directory path to ncRNAScan pipeline');
    }
    else {
	$outdir = $io->validate_create_path($out, 'create',
					    'Directory path to ncRNAScan pipeline')
    }

    my $s_time = $io->start_timer;
    $io->c_time('Starting ncRNAScan Pipeline...');

    my $dep_tools_fh = $io->open_file('<', $USER_HOME . '/.ncRNAScan.depconf');
    my $dep_tools = do {local $/; <$dep_tools_fh>};
    ($deps->{'cuffcompare'}) = ($dep_tools =~ m/(.+?cuffcompare)/i);
    ($deps->{'blastall'}) = ($dep_tools =~ m/(.+?blastall)/i);
    ($deps->{'RNAfold'}) = ($dep_tools =~ m/(.+?rnafold)/i);
    ($deps->{'cat'}) = ($dep_tools =~ m/(.+?$CAT_SC)/i);
    ($deps->{'fetch'}) = ($dep_tools =~ m/(.+?$FETCH_SC)/i);
    ($deps->{'get'}) = ($dep_tools =~ m/(.+?$GET_UQ_SC)/i);

    $io->c_time('Validating options...');
    $io->verify_options([$is_valid_option]);
    $io->exist_sys_cmd(['mkdir']);

    my $cuffcmp_dir = $outdir . 'cuffcompare';    

    # Run cuffcompare ################################################################################
    do {

	$io->c_time('Module 1: Running cuffcompare...');
	$io->execute_system_command("mkdir -p $cuffcmp_dir",
				    'Making output directory for cuffcompare [ ' . $cuffcmp_dir . ' ]')
	    if (!-d $cuffcmp_dir);
	
	$io->execute_system_command($deps->{'cuffcompare'} . ' ' .
                                join('-', split(/\-/, $cuffcmp_opts)) .
				    " -o $cuffcmp_dir/ncRNAScan_cuffcmp ", 
				    "Command call:\n" .
				    "-------------\n" . $deps->{'cuffcompare'} . ' ' . 
				    join('-', split(/\-/, $cuffcmp_opts)) .
				    " -o $cuffcmp_dir/ncRNAScan_cuffcmp ");
    
    } if (defined($cuffcmp_opts) && $cuffcmp_opts ne '');
    

    # Run categorize_ncRNAs.pl ########################################################################
    do {

	$io->c_time('Module 2: Running categorize_ncRNAs.pl');
	my $cat_dir = $outdir . 'categorize_ncRNAs';
	$io->execute_system_command("mkdir -p $cat_dir",
				    'Making output directory for ' .
				    $io->file_basename($deps->{'cat'}, 'suffix') .
				    ' [ ' . $cat_dir . ' ]')
	    if (!-d $cat_dir);
	
	my ($tr_files, $tr_size) = get_num_tr_files($cuffcmp_opts)
	    if (defined $cuffcmp_opts && $cuffcmp_opts ne '');
		
	$io->execute_system_command('perl' . $pl_inc_string . $deps->{'cat'} . ' ' .
				    join('-', split(/\-|\--/, $categorize_sc_opts)) .
				    " -cuffcmp $cuffcmp_dir/ncRNAScan_cuffcmp.tracking -out $cat_dir " .
				    $tr_files, 
				    "Command call:\n" .
				    "-------------\n" . $deps->{'cat'} . ' ' . 
				    join('-', split(/\-|\--/, $categorize_sc_opts)) . 
				    " -cuffcmp $cuffcmp_dir/ncRNAScan_cuffcmp.tracking -out $cat_dir " .
				    $tr_files);
    
    } if (defined($categorize_sc_opts) && $categorize_sc_opts ne '');

    # Run get_unique_features.pl ######################################################################
    do {

	$io->c_time('Module 3: Running get_unique_features.pl');
        my $cat_dir = $outdir . 'get_unique_features';
        $io->execute_system_command("mkdir -p $cat_dir",
                                    'Making output directory for ' .
				    $io->file_basename($deps->{'get'}, 'suffix') .
				    ' [ ' . $cat_dir . ' ]')
            if (!-d $cat_dir);
	
	opendir (ncRNAScan_categorize_mod, $outdir . 'categorize_ncRNAs') ||
	    $io->error("Cannot open directory $outdir" .
		       'categorize_ncRNAs to read ncRNAScan class files.');

	push my @ncRNAScan_class_files, grep {/putative\.class\.ncRNAs\.gtf$/} readdir ncRNAScan_categorize_mod;

	foreach my $ncRNAScan_class_file (@ncRNAScan_class_files) {

	    $ncRNAScan_class_file = $outdir . 'categorize_ncRNAs/' . $ncRNAScan_class_file;
	    my $unique_ncRNAs = $cat_dir . '/' . $io->file_basename($ncRNAScan_class_file) . '.unique.gtf';

	    $io->execute_system_command('perl' . $pl_inc_string . $deps->{'get'} . ' ' .
					'-cf ' . $ncRNAScan_class_file . ' -cff gtf -sff bed '.
					join('-', split(/\-|\--/, $get_uq_sc_opts)) .
					' -q -stdout -unique -kc 3 -ck transcript | ' .
					"grep -oiP 'transcript_id\\s+.+?\\\;' | grep -oiP '\\\".+?\\\"' | sed -e 's/\\\"//g' | " .
					"while read line; do grep \$line $ncRNAScan_class_file; done" .
					" > $unique_ncRNAs",
					"Command call:\n" .
					"-------------\n" . $deps->{'get'} . ' ' .
					'-cf ' . $ncRNAScan_class_file . ' -cff gtf -sff bed '.
					join('-', split(/\-|\--/, $get_uq_sc_opts)) .
					' -q -stdout -unique -kc 3 -ck transcript ' .
                                        " > $unique_ncRNAs");
	}
	close ncRNAScan_categorize_mod;
	
    } if (defined($get_uq_sc_opts) && $get_uq_sc_opts ne '');
    
	
    # Run fetch_seq_from_ucsc.pl ######################################################################
    do {

	$io->c_time('Module 4: Running fetch_seq_from_ucsc.pl');
        my $cat_dir = $outdir . 'fetch_seq_from_ucsc';
        $io->execute_system_command("mkdir -p $cat_dir",
                                    'Making output directory for ' . $io->file_basename($deps->{'get'}, 'suffix') . ' [ ' . $cat_dir . ' ]')
            if (!-d $cat_dir);

	opendir (ncRNAScan_get_unique_mod, $outdir . 'get_unique_features') ||
            $io->error("Cannot open directory $outdir" .
                       'get_unique_features to read unique ncRNA features.');

        push my @ncRNAScan_unique_files, grep {/putative\.class\.ncRNAs\.unique\.gtf$/} readdir ncRNAScan_get_unique_mod;

	foreach my $ncRNAScan_unique_file (@ncRNAScan_unique_files) {
	    $ncRNAScan_unique_file = $outdir . 'get_unique_features/' . $ncRNAScan_unique_file;

	    $io->execute_system_command('perl' . $pl_inc_string . $deps->{'fetch'} . ' ' .
					join('-', split(/\-|\--/, $fetch_sc_opts)) .
					' -tmap ' . $ncRNAScan_unique_file .
					" -out $cat_dir -ff gtf -id 'transcript_id.+?\\\"(.+?)\\\"' -skip '\\texon\\t' -q",
					"Command call:\n" .
					"-------------\n" . $deps->{'fetch'} . ' ' .
					join('-', split(/\-|\--/, $fetch_sc_opts)) .
					' -tmap ' . $ncRNAScan_unique_file .
                                        " -out $cat_dir -ff gtf -id 'transcript_id.+?\\\"(.+?)\\\"' -skip '\\texon\\t' -q");
	}
	close ncRNAScan_get_unique_mod;

    } if (defined($fetch_sc_opts) && $fetch_sc_opts ne '');
    
    $io->c_time('ncRNAScan Pipeline Finished!');
    $io->end_timer($s_time);
}

sub setup_ncRNAScan {
    chomp(my $install_dir = shift);
    chomp(my $dl_util = `which wget 2>&1`);

    print "\nChecking for platform independent prerequisites on UNIX based machines...\n";

    # Wget or Curl
    if ($dl_util !~ m/.+?wget$/i) {
	chomp ($dl_util = `which curl 2>&1`);
	succ_or_fail(0, 'Curl|Wget')
	    if ($dl_util !~ m/.+?curl$/i);
	succ_or_fail(1, 'curl');
        $dl_util .= ' -LkO ';
    }
    elsif ($dl_util =~ m/.+?(wget)$/i) {
	succ_or_fail(1, $1);
    }
    else{
	succ_or_fail(0, 'Curl|Wget');
    }

    # Unzip
    check_util('unzip');

    # Make
    check_util('make');

    # Echo
    check_util('echo');

    # Uname
    check_util('uname');

    print "\n\nWe definetely need the custom module, IO::Routine.\n" .
      "We also need good grace of cpanm to install remaining modules.\n\n" .
	"Attempting to fetch IO::Routine from Perl-for-Bioinformatics repository on github...\n";

    if (-d "$install_dir/.build") {
	system("rm -rf $install_dir/.build");
    }

    system("mkdir $install_dir/.build");
    succ_or_fail(0, '.build dir') if (!-d "$install_dir/.build");

    system("rm $install_dir/master.zip") if (-e "$install_dir/master.zip");

    my $dl_util_slave = '';
    if ($dl_util =~ m/.*?wget$/i) {
      $dl_util_slave = $dl_util . ' -O master.zip ';
    }
    else {
      $dl_util_slave = $dl_util;
    }
     print "\n$dl_util_slave https://github.com/biocoder/Perl-for-Bioinformatics/archive/master.zip\n\n";
    system("$dl_util_slave https://github.com/biocoder/Perl-for-Bioinformatics/archive/master.zip > /dev/null 2>&1");
    system("mv $install_dir/master.zip $install_dir/.build/master.zip");

    succ_or_fail(0, 'master.zip')
	if (!-e "$install_dir/.build/master.zip");

    print "\nInflating master.zip...\n";
    print "\nunzip -d $install_dir/.build $install_dir/.build/master.zip\n";
    system("unzip -d $install_dir/.build $install_dir/.build/master.zip  > /dev/null 2>&1");

    print "\nInstalling IO::Routine...\n\n";
    system("mkdir $install_dir/PERLLIBS") if (!-d "$install_dir/PERLLIBS");
    my $custom_pm_log = `cd $install_dir/.build/Perl-for-Bioinformatics-master/IO-Routine;perl Makefile.PL PREFIX=$install_dir/PERLLIBS LIB=$install_dir/PERLLIBS/lib && make && make test && make install; 2>&1`;

    if ($custom_pm_log =~ m/fail|error/i) {
	succ_or_fail(0, 'IO::Routine');
    }
    else {
	succ_or_fail(1, 'IO::Routine');
    }

    # Use cpanm to install Set::IntervalTree
    system("$dl_util https://raw.github.com/miyagawa/cpanminus/master/cpanm  > /dev/null 2>&1");
    system("mv cpanm $install_dir/.build");
    system("chmod 755 $install_dir/.build/cpanm");

    cpanm_status($install_dir, 'Set::IntervalTree');
    cpanm_status($install_dir, 'LWP::Simple');
    cpanm_status($install_dir, 'XML::XPath');
    cpanm_status($install_dir, 'XML::XPath::XMLParser');

    print "\n\nThank you cpanm!\n";
    print "\nCleaning up build directory...\n";
    system("rm -rf $install_dir/.build");

    my $pm_path = "$install_dir/PERLLIBS:$install_dir/PERLLIBS/lib:$install_dir/PERLLIBS/lib/perl5";

    require "$install_dir/PERLLIBS/lib/IO/Routine.pm";
    my $io = IO::Routine->new($help, $quiet);

    $io->execute_system_command(0, 'Detecting system architecture...');

    my $sys_arch_info = $io->execute_get_sys_cmd_output('uname -a');

    $io->error('This is not a UNIX based machine ... Aborting installation!')
	if (!$sys_arch_info ||
	    $sys_arch_info !~ m/linux|darwin/i);

    $io->error('It is not a 64-bit machine!' . 
	       "\nIt is your responsibility to make sure that you have the following tools" .
	       " installed for your system architecture and also must be found in \$PATH:\n" .
	       "\nblastall, cuffcompare and RNAfold\n\nBailing out!") 
	if ($sys_arch_info !~ m/x86\_64/i);


    my $sys_arch = '';
    if ($sys_arch_info =~ m/darwin/i) {
	$sys_arch = 'darwin';
	$io->execute_system_command(0, 'Skipping version requirement check for system level commands [ tar ], [ cut ] and [ wc ].' .
				    "\nFreeBSD's tools does not provide version numbers (?)");
	check_util('tar');
	check_util('cut');
	check_util('wc');
	print "\n";

	$io->warning("We need GNU's grep and sed instead of FreeBSD's.");
	chomp(my $homebrew = `which brew 2>&1`);
	print "\nLooking to see if you have homebrew to install GNU tools [ grep and sed ] ...\n";

	if ($homebrew =~ m/.*brew$/i) {
	    succ_or_fail(1, 'homebrew');
	}
	else {
	    $io->error('Please install homebrew. See installation instructions at http://brew.sh/');
	}
	print "\n\nPlease execute following commands in order and" .
	    ' reload your shell after ncRNAScan setup is complete to ' .
                "successfully install GNU tools [ grep and sed]:\n";
	$io->execute_system_command(0,
				    "brew install grep\nbrew install gnu-sed\n" .
				    "ln -s /usr/local/bin/ggrep /usr/local/bin/grep\n" .
				    "ln -s /usr/local/bin/gsed /usr/local/bin/sed");
	print "Skipping version check for GNU grep and GNU sed...\n";
	succ_or_fail(2, 'sed');
	succ_or_fail(2, 'grep');
    }
    else {
	$sys_arch = 'linux';
	 $io->check_sys_level_cmds(['grep', 'sed', 'tar', 'cut', 'wc'],
				   ['2.6.3', '4.2.1', '0', '8', '8']);

	succ_or_fail(1, 'grep');
	succ_or_fail(1, 'sed');
	succ_or_fail(1, 'tar');
	succ_or_fail(1, 'cut');
	succ_or_fail(1, 'wc');
    }

    print "\n\nSetting up PERL5LIB paths...\n";
    unlink "$USER_HOME/.ncRNAScan.PERLLIBS" if (-e "$USER_HOME/.ncRNAScan.PERLLIBS");
    my $pl_dep_fh = $io->open_file('>', "$USER_HOME/.ncRNAScan.PERLLIBS");
    print $pl_dep_fh $pm_path;

    $io->execute_system_command(0,
				"\nChecking for ncRNAScan pipeline tool dependencies..." .
				"\n\nWriting tool dependency chain to $USER_HOME/.ncRNAScan.depconf");

    my $dep_fh = $io->open_file('>', "$USER_HOME/.ncRNAScan.depconf");

    # We will figure out if user is installing at a different location other than
    # from the cloned repo.
    my @inst_file_parts = $io->file_basename($0, 'all');
    chop $inst_file_parts[1] if ($inst_file_parts[1] =~ m/\/$/);
    $install_dir = $inst_file_parts[1] if (-d "$inst_file_parts[1]/.ncRNAScan.depbin" && $inst_file_parts[1] !~ m/^\./);

    print $dep_fh check_bio_util('cuffcompare', $install_dir, $sys_arch), "\n";
    print $dep_fh check_bio_util('blastall', $install_dir, $sys_arch), "\n";
    print $dep_fh check_bio_util('RNAfold', $install_dir, $sys_arch), "\n";
    print $dep_fh "$install_dir/" . $CAT_SC, "\n" if (check_native("$install_dir/" . $CAT_SC));
    print $dep_fh "$install_dir/" . $FETCH_SC, "\n" if (check_native("$install_dir/" . $FETCH_SC));
    print $dep_fh "$install_dir/" . $GET_UQ_SC, "\n" if (check_native("$install_dir/" . $GET_UQ_SC));

    close $dep_fh;
    $io->execute_system_command(0,
				"\n\nSetup complete. See ncRNAScan -h to run the pipeline with options.");
}


# Check for pipeline scripts.
sub check_native {
    my $nat_sc = shift;
    (my $sc) = ($nat_sc =~ m/.*\/(.+?\.pl)$/);

    if (-e $nat_sc) {
	succ_or_fail(1, $sc);
	return 1;
    }
    else {
	succ_or_fail(0, $sc);
    }
    return 0;
}

# Check for dependencies
sub check_bio_util {
    my $cmd = shift;
    my $install_dir = shift;
    my $sys_arch = shift;

    chomp (my $biocmd4arch = `which $cmd 2>&1`);
    my $sandboxed4arch = $sys_arch . '_' . $cmd;

    if ($biocmd4arch !~ m/.*$cmd$/i &&
        -d "$install_dir/.ncRNAScan.depbin" &&
        -e "$install_dir/.ncRNAScan.depbin/$sandboxed4arch") {
        succ_or_fail(1, $cmd);
	$biocmd4arch = "$install_dir/.ncRNAScan.depbin/$sandboxed4arch";
    }
    elsif ($biocmd4arch =~ m/.*$cmd$/i) {
	succ_or_fail(1, $cmd);
    }
    else {
	succ_or_fail(0, $cmd);
    }
    return $biocmd4arch;
}

# Check for system utilities
sub check_util {
    my $cmd = shift;
    chomp (my $util = `which $cmd 2>&1`);

    if ($util !~ m/.+?$cmd/i) {
	succ_or_fail(0, $cmd);
	print "\nAborting...\n\n";
	exit;
    }
    else {
        succ_or_fail(1, $cmd);
    }
    return $util;
}

# Print success or failure
sub succ_or_fail {
    my $code = shift;
    my $msg = shift;

    my $char_white_space = 70 - length($msg);

    print "\n";
    printf("%s%*s%s", $msg, $char_white_space, '... ', BOLD GREEN . 'OK' . RESET)
	if ($code == 1);

    if ($code == 0) {
	printf("%s%*s%s", $msg, $char_white_space, '... ',  BOLD RED . 'FAIL' . RESET);
	print "\n\n";
	exit;
    }

    printf("%s%*s%s", $msg, $char_white_space, '... ', BOLD YELLOW . 'SKIP' . RESET)
         if ($code == 2);
    return;
}

# Source the environment
sub source_env {
    chomp(my $pl_paths = shift);
    my $perl_inc_string = ' ';
    
    foreach my $pl_path (split(/\:/, $pl_paths)) {
	$perl_inc_string .= '-I' . $pl_path . ' ';
	push @INC, $pl_path;
    }
    return $perl_inc_string;
}

# Report cpanm status
sub cpanm_status {
    my $install_dir = shift;
    my $pm = shift;
    my $cpanm_log = `$install_dir/.build/cpanm -f -l $install_dir/PERLLIBS $pm 2>&1`;

    succ_or_fail(0, $pm) if ($cpanm_log !~ m/.*?success.*/i);
    succ_or_fail(1, $pm);
    return;
}

# Report transcript files and size
sub get_num_tr_files {
    my $cmd_args = shift;
    my @args = split/\s+/, $cmd_args;
   
    my $last_opt_elem = my $tr_size = 0;
    my $tr_files = '';
    
    for (0 .. $#args) {
	$last_opt_elem = $_ + 2 if ($args[$_] =~ m/^\-/);
    }
    $tr_size = $#args - $last_opt_elem;
    
    $tr_files = join(' ', @args[$last_opt_elem .. $#args]);
    return($tr_files, $tr_size);
}


# Ask for user input
sub ask_user {
 my $msg = shift;
 print $msg, ': ';
 chomp(my $ans = <STDIN>);
 return $ans;
}

__END__

=head1 NAME

ncRNAScan

=head1 SYNOPSIS

ncRNAScan is a pipeline to extract putative novel ncRNAs ab initio, given a list of transcripts in GTF format assembled from deep sequencing data (ex: RNA-Seq).

Complete Description: 

    perldoc ncRNAScan

Examples:

    perl ncRNAScan -h

    perl ncRNAScan -cuffcmp '-r annotation.gtf ...' -categorize '-fpkm 2 -l 200 ...' -get '-unique -q -sff bed -cff gtf...' -fetch '-db mm10'


=head1 DESCRIPTION

This pipeline script will bind together the functionality of the tools / scripts: Cuffcompare, categorize_ncRNAs.pl, get_unique_features.pl, fetch_seq_from_ucsc.pl and / or Coding Potential Calculator (CPC). Transcriptome construction tools such as Scripture / Cufflinks produces a set of assembled transcripts in GTF format. ncRNAScan uses this data in addition to known gene annotation to extract putative ncRNAs constructed by the ab initio assemblers. In brief, the pipeline steps are as follows:

=over 5

=item 1. Cuffcompare (ncRNAScan Option: -cuff or --cuffcompare)

    The transcript assembly can be compared to known annotation of choice to classify them into different class codes (http://cufflinks.cbcb.umd.edu/manual.html#class_codes) using Cuffcompare. 

=item 2. categorize_ncRNAs.pl (ncRNAScan Option: -cat or --cat-ncRNAs)
    
    ncRNAScan uses the tracking file (*.tracking) produced by Cuffcompare, annotation data in gene prediction format and a list of supplied transcripts in GTF format to produce and categorize ncRNAs into different classes as mentioned in the paper, http://genome.cshlp.org/content/22/3/577.full. 

=item 3. get_unique_features.pl (ncRNAScan Option: -get or --get-feat)
    
    It then compares the putative list with supplied known ncRNAs in BED format to get features that do not overlap any known ncRNAs.

=item 4. fetch_seq_from_ucsc.pl (ncRNAScan Option: -fetch or --fetch-seq)
    
    This list is then used to fetch DNA sequence of those transcript sequences to determine the coding potential using CPC.

=item 5. run_CPC.sh (ncRNAScan Option -cpc or --run-cpc)
    
    In the final step, the fetched FASTA sequences are used to determine and coding potential and those that are flagged as "noncoding" are used to create the final list of high confidence ncRNAs.

=back

The pipeline has the ability to run each of these individual modules if any of them fail during the initial run.

=head1 EXAMPLE

=head2 Installation:

=over 5

=item * This script will try its best to setup the pipeline on the suitable architecture.

perl ncRNAScan -setup

=back

=head2 Start the Pipeline:

=over 5

=item * Run the complete pipeline:

    perl ncRNAScan -run -out /data/ncRNAScan/ -cuff '-r /data/projects/mm10/macrophages/rna-seq/cuffcompare.m0.m1.m2_vs_ensembl_ref_known/refSeq_UCSCKnownGenes_Ensemble.gtf -s /data/ref_fasta/mm10_UCSC/whole_genome.fa /data/projects/mm10/macrophages/rna-seq/m0/cufflinks/transcripts.gtf /data/projects/mm10/macrophages/rna-seq/m1/cufflinks/transcripts.gtf /data/projects/mm10/macrophages/rna-seq/m2/cufflinks/transcripts.gtf' -cat '-clean -overlap 1.1 -min-exons 1 -fpkm 2 -annotation /data/projects/mm10/macrophages/ncrna/2lncRNA/allGenes.txt -antisense -sample-names "M0,M1,M2"' -get '-sf /data/projects/mm10/macrophages/ncrna/known_ref_ncRNAs/mm10_ncRNA.bed' -fetch '-db mm10'

=item * Run categorize_ncRNAs module of the pipeline:
    
    perl ncRNAScan -run -out /data/ncRNAScan/ -cat '-clean -overlap 1.1 -min-exons 1 -fpkm 2 -annotation /data/projects/mm10/macrophages/ncrna/2lncRNA/allGenes.txt -antisense -sample-names "M0,M1,M2" /data/projects/mm10/macrophages/rna-seq/m0/cufflinks/transcripts.gtf /data/projects/mm10/macrophages/rna-seq/m1/cufflinks\
/transcripts.gtf /data/projects/mm10/macrophages/rna-seq/m2/cufflinks/transcripts.gtf' -get '-sf /data/projects/mm10/macrophages/ncrna/known_ref_ncRNAs/mm10_ncRNA.bed' -fetch '-db mm10'

=item * Run get_unique_features module of the pipeline:
    
    perl ncRNAScan -run -out /data/ncRNAScan -get '-sf /data/projects/mm10/macrophages/ncrna/known_ref_ncRNAs/mm10_ncRNA.bed'

=item * Run fetch_unique_features module of the pipeline:

    perl ncRNAScan -run -out /data/ncRNAScan -fetch '-db mm10'

=back

=head1 OPTIONS

ncRNAScan takes the following arguments:

=over 4

=item -h or --help (Optional)
    
    Displays this helpful message.

=item -setup or --setup
    
    Try to setup the pipeline with all its dependencies.

=item -cuff or --cuffcompare (Optional)

    Run the Cuffcompare module with the supplied options.

=item -cat or --cat-ncRNAs (Optional)

    Run the categorize_ncRNAs.pl module with supplied options.

=item -get or --get-feat (Optional)

    Run the get_unique_features.pl module  with the supplied options.

=item -fetch or --fetch-seq (Optional)

    Run the fetch_seq_from_ucsc.pl module with the supplied options.

=item -cpc or --run-cpc (Optional)

    Run the CPC module with the supplied options.

=back

=head1 AUTHOR

Kranti Konganti, E<lt>konganti@tamu.eduE<gt>.

=head1 COPYRIGHT

This program is distributed under the Artistic License.

=head1 DATE

Oct-30-2013

=cut
